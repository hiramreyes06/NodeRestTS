En este sistema para poder subir archivos al servidor , se debe de crear una
carpeta por usuario de la bd en base a su id de mongo, conforme vallan 
subiendo arhivos, la cual contendra 2 carpetas una temporal y otra de posts que 
se encargara de guardar permanentemente. Despues al subir el archivo lo 
debemos renombrar con un generaror de ids aleatorios para que no se repitan.
Para generar ids aleatorios instalamos el paquete 

npm install uniqid

Primero necesitamos crear una interfaz para poder manejar los archivos en
base a express, en una carpeta interfaze creamos un fileUpload.ts el cual
tendra

export interface IFileUpload{
name:string;
data:any;
encoding: string;
tempFilePath:string;
truncated: boolean;
mimetype:string;
mv: Function;
} 


Ahora crearemos una clase que manejara los metodos y todo lo relacionado
con el manejo de archivos, para eso en la carpeta classes creamos una llamada
file-system.ts en la cual tendra los metodos...

import { IFileUpload } from '../interfaces/fileUpload';

import path from 'path';

import fs from 'fs';

import uniqid from 'uniqid';



//Necesitamos poder exportar esta clase para usarla
export default class FileSystem{

constructor(){};

//Tenemos que convertir esta funcion a una promesa para esperar a que 
//se complete
guardarImagenTemporal( file: IFileUpload, userId: string){


return new Promise( (resolve,reject) =>{



    const path = this.crearCarpetaUsuario(userId);

    const nombreArchivo= this.generarNombreUnico(file.name);
    
    //Mover archivo de la carpeta temp a la del usuar
    file.mv(`${path}/${ nombreArchivo}`, (err:any)=>{
    
    if(err){
        console.log(err);
        reject(err);
    }

    resolve();
    
    } );



});



}

private generarNombreUnico(nombreOriginal: string) :string{

const nombreArr= nombreOriginal.split('.');
const extension= nombreArr[ nombreArr.length-1];

const idUnico= uniqid();
return `${ idUnico }.${extension}`;
}


private crearCarpetaUsuario(userId: string): string{

    //Ruta de la carpeta del usuario
   const pathUser= path.resolve(__dirname,'../uploads/', userId);  
//    console.log(pathUser);

   const pathUserTemp= pathUser+'/temp';

   const existe= fs.existsSync( pathUser);

   if(! existe){
       fs.mkdirSync(pathUser);
       fs.mkdirSync(pathUserTemp);
   }


   return pathUserTemp;
}


imagenesDeTempHaciaPost(userId: string){

    const pathUserTemp= path.resolve(__dirname,'../uploads/', userId,'temp');
    const pathUserPost= path.resolve(__dirname,'../uploads/', userId,'post');

    if(!fs.existsSync(pathUserTemp)){

        return [];
    }
    if(!fs.existsSync(pathUserPost)){

        fs.mkdirSync(pathUserPost);
    }

    const imagenesTemp= this.obtenerImagnesEnTemp( userId );

    //Asi movemos de lugar las imagenes de temp a post
    imagenesTemp.forEach( imagen =>{
        fs.renameSync(`${pathUserTemp}/${imagen}`, `${pathUserPost}/${imagen}`);
    });

    //Esto retorna el nombre de las imagenes movidas a pst
    return imagenesTemp;

 }

 private obtenerImagnesEnTemp(userId:string){

    const pathUserPost= path.resolve(__dirname,'../uploads/', userId,'temp');
    //Se obtiene un arreglo de todos los archivos en temp
    //si no existe alguno retorna null
    return fs.readdirSync(pathUserPost) || [];
 }


 getFotoUrl(usuarioId:string, img: string): string{

    const pathUserImg= path.resolve(__dirname,'../uploads/', usuarioId,'post',img);

   const existe= fs.existsSync(pathUserImg);

    if(!existe){
      //retorna la foto de 404 en assets
       return path.resolve(__dirname,'../assets/imgs/404.jpg');
    }
 
   return pathUserImg;
 
 
    }
}


**Ahora necesitamos una ruta de express que se va a encargar de recibir los
archivos mediante un post, con la siguiente estructura, primero importamos
la clase y la interfaz para poder acceder a los metodos

import { IFileUpload } from '../interfaces/fileUpload';
import FileSystem from '../clases/file-system';

/La funcion debe ser asincona para esperar que la promesa sea resuelta
postRoutes.post(`/upload`, verificarToken, async (req:any, res:Response) =>{

if(!req.files){
    return res.status(400).json({
        ok:false,
        message:'No se recibio el archivo'

    });
}

const file: IFileUpload= req.files.image;

if(!file){
return res.status(400).json({
ok:true,
message:'El archivo no tiene el key image'
});
}

if(!file.mimetype.includes('image')){
    return res.status(400).json({
    ok:true,
    message:'El archivo no es una imagen'
    });
    }


    //El metodo tiene que esperar que esta promesa sea resuelta
  await  fileSystem.guardarImagenTemporal(file, req.usuario._id);

res.json({
    ok:true,
    file: file.mimetype
});


});

Ahora para que express reconosca los archivos recibidos, necesitamos
aplicarle un middleware en el index del servidor.. importamos

import fileUpload from 'express-fileupload';

//De preferencia debe estar debajo del body parser
//File upload para subir archivos
//Si detecta algun  archivo en la peticion estara en el req.files
//Debemos que agregar la propiedad para que no guarde un archivo vacio
server.app.use(fileUpload({
    useTempFiles:true
}));


